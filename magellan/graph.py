import networkx as nx

from magellan.json_io import gen_json


class Graph(nx.DiGraph):
    def __init__(
        self, remove_cycle=True, remove_sign=True, remove_neither=True, **attr
    ):
        super().__init__(**attr)

        self.remove_cycle = remove_cycle
        self.remove_sign = remove_sign
        self.remove_neither = remove_neither

    def to_json(
        self,
        to_dir: str,
        model_name: str,
        scale: float = 2,
        min_range: int = 0,
        max_range: int = 2,
        func_type: str | None = None,
        gene_sets: dict | None = None,
        colour_dic: dict | None = None,
    ):
        """
        Generate .json file for BMA model

        :param to_dir: str, target directory to store .json file
        :param model_name: str, name of BMA model (and .json file)
        :param scale: scalar, scale of node coordinates, which are automatically generated by pygraphviz
        :param min_range: scalar, minimum value of nodes
        :param max_range: scalar, maximum value of nodes
        :param func_type: type of default target function
        :param gene_sets: dict of sets, key: gene type (mut, pheno, deg), value: sets of genes corresponding to key
        :param colour_dic: dict, dictionary of colours by gene type

        """

        gen_json(
            self,
            to_dir,
            model_name,
            scale=scale,
            min_range=min_range,
            max_range=max_range,
            func_type=func_type,
            gene_sets=gene_sets,
            colour_dic=colour_dic,
        )

    def _gen_graph(self, df, source_col, target_col, weights, sign_to_keep):
        """

        Generate a graph from shortest path results

        :param df: pandas.DataFrame, row: edge tuple (u, v), column: columns corresponding to weights in Omnipath
        :param source_col: str, column name of source nodes
        :param target_col: str, column name of target nodes
        :param weights: tuple, column names of interest
        :param sign_to_keep: str, Activator or Inhibitor, the sign to keep when an edge is both activator and inhibitor

        """

        if df.index.dtype == "int":
            df.index = zip(df[source_col], df[target_col])

        if sign_to_keep not in ["Activator", "Inhibitor"]:
            raise ValueError(
                "sign_to_keep must be one of the following: Activator, Inhibitor"
            )

        # rename direction_type as sign (if not already done so)
        # substitute: stimulation to Activator, inhibition to Inhibitor
        # for consistent notations in BMA
        # df.rename(columns={'direction_type': 'sign'}, inplace=True)
        # df.replace(to_replace={'sign': {'stimulation': 'Activator',
        #                                 'inhibition': 'Inhibitor'}},
        #            inplace=True)
        # df['sign'] = df['sign'].str.capitalize()  # capitalise sign column for consistency

        # remove edges with undefined sign
        if self.remove_neither:
            df = df[df["sign"] != "Neither"]

        # set sign to activator OR inhibitor if an edge is both activator and inhibitor
        # default: activator (remove inhibitor)
        if self.remove_sign:
            df[df["sign"] == "Both"] = sign_to_keep

        weights = list(weights)
        to_add = []
        for col in weights:
            if df[col].dtypes not in ["int", "float"]:
                try:
                    df[col] = df[col].astype(float)
                except ValueError:
                    continue

            df["reciprocal_%s" % col] = 1.0 / df[col]
            to_add += ["reciprocal_%s" % col]

        weights += to_add
        del to_add

        # Remove duplicate edges by keeping the first occurrence
        df = df[~df.index.duplicated(keep="first")]  # type: ignore

        # generate edge dictionary
        edge_dic = df[weights].T.to_dict()

        # add edges and attributes
        self.add_edges_from(edge_dic.keys())
        nx.set_edge_attributes(self, values=edge_dic)

    def _find_cycle(self):
        """
        Find direct cycles (cycles formed by a pair of nodes) in the graph
        :return: a set of edge tuples

        """

        # sort edge by alphabetic order to avoid iterating over both (u, v) and (v, u)
        edge_set = {tuple(sorted(list(e))) for e in self.edges()}
        edge_all = set(self.edges())

        return {
            (u, v) for (u, v) in edge_set if ((u, v) in edge_all) & ((v, u) in edge_all)
        }

    def _compare_edge(self, u, v, weight="n_references"):
        """
        Compare edges (u, v) and (v, u) by weight, and remove the one with lower weight

        :param u: str, forms a direct cycle with v
        :param v: str, forms a direct cycle with u
        :param weight: str, name of weight, default: n_references

        """

        # edge (u-->v) has more ref than reverse edge (v-->u), delete v-->u
        if self[u][v][weight] > self[v][u][weight]:
            self.remove_edges_from([(v, u), (v, u)])
        # edge (v-->u) has more ref than reverse edge (u-->v), delete u-->v
        elif self[u][v][weight] < self[v][u][weight]:
            self.remove_edges_from([(u, v), (u, v)])
        # edge (v-->u) and edge (u-->v) have the same ref, keep both
        else:
            pass

    def _remove_cycle_edge(self, cycle, weight="n_references"):
        """
        Select the edge with higher weight in direct cycles

        :param cycle: set of edge tuples that are direct cycles
        :param weight:  str, name of weight, default: n_references

        """

        for u, v in cycle:
            self._compare_edge(u, v, weight)

    def _remove_cycle(self, weight="n_references"):
        """
        Remove direct cycles from the graph
        :param weight: weight:  str, name of weight, default: n_references

        """

        cycle = self._find_cycle()
        self._remove_cycle_edge(cycle, weight)

    def filter_by_weight(self, weight="curation_effort", threshold=15):
        """
        Remove edges whose weight is smaller than a threshold

        :param weight: str, name of weight to be checked
        :param threshold: int, cut-off threshold

        """

        for u, v in set(self.edges()):
            if self[u][v][weight] < threshold:
                self.remove_edges_from([(u, v), (u, v)])

    def gen_graph(
        self,
        df,
        source_col="from (shortest path)",
        target_col="to (shortest path)",
        weights=(
            "sign",
            "curation_effort",
            "n_references",
            "n_sources",
            "n_primary_sources",
        ),
        sign_to_keep="Activator",
        remove_cycle_by="n_references",
    ):
        """

        Generate a graph from shortest path results

        :param df: pandas.DataFrame, row: edge tuple (u, v), column: columns corresponding to weights in Omnipath
        :param source_col: str, column name of source nodes
        :param target_col: str, column name of target nodes
        :param weights: tuple, column names of interest
        :param sign_to_keep: str, Activator or Inhibitor, the sign to keep when an edge is both activator and inhibitor
        :param remove_cycle_by: str, name of weight to be compared to remove one direction of the direct cycles

        """

        self._gen_graph(df, source_col, target_col, weights, sign_to_keep)

        if self.remove_cycle:
            self._remove_cycle(remove_cycle_by)
